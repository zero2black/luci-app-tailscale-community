name: Build OpenWrt Package

on:
  push:
    branches: [ "main", "master" ]
    tags: [ "v*" ]
  pull_request:
    branches: [ "main", "master" ]
  workflow_dispatch:

env:
  OPENWRT_VERSION: v25.12.0-rc2
  PACKAGE_NAME: luci-app-tailscale-community
  SDK_DIR: /home/runner/work/openwrt-sdk

permissions:
  contents: write

jobs:
  build:
    name: Build Packages for ${{ matrix.target.name }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        target:
          - name: x86_64
            path: x86/64

    steps:
      - name: Checkout package repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential rsync unzip zstd coreutils cmake
          sudo ln -sf /usr/bin/sha256sum /usr/bin/sha256

      - name: Setup usign
        run: |
          git clone --depth 1 https://github.com/openwrt/usign.git
          cd usign && mkdir build && cd build
          cmake .. && make -j$(nproc)
          sudo make install
          cd ../.. && rm -rf usign

      - name: Cache OpenWrt SDK
        id: cache-sdk
        uses: actions/cache@v4
        with:
          path: ${{ env.SDK_DIR }}
          # 缓存键：结合操作系统、目标架构和 OpenWrt 版本，确保环境变化时缓存失效
          key: ${{ runner.os }}-sdk-${{ matrix.target.name }}-${{ env.OPENWRT_VERSION }}

      - name: Download, extract OpenWrt SDK and update feeds
        if: steps.cache-sdk.outputs.cache-hit != 'true'
        run: |
          # 从环境变量中移除 'v' 前缀以匹配版本号
          release_version="${OPENWRT_VERSION#v}"
          sdk_url_prefix="https://downloads.openwrt.org/releases/${release_version}/targets/${{ matrix.target.path }}"

          # 查找 SDK 文件名
          sdk_filename=$(curl -s "$sdk_url_prefix/" | \
                        grep -o '<a href="openwrt-sdk-.*-x86_64\.tar\.\(xz\|zst\)">' | \
                        sed -e 's/.*<a href="//' -e 's/">//' | \
                        head -n 1)

          if [ -z "$sdk_filename" ]; then
            echo "::error::Could not find SDK file at ${sdk_url_prefix}/"
            echo "Available files:"
            curl -s "$sdk_url_prefix/" | grep -o '<a href="[^"]*">[^<]*</a>' | sed -e 's/<a href="\(.*\)".*>\(.*\)/\1\t\2/'
            exit 1
          fi

          echo "Downloading SDK: ${sdk_url_prefix}/${sdk_filename}"
          wget -q "${sdk_url_prefix}/${sdk_filename}"

          echo "Extracting SDK..."
          # 解压 SDK 并重命名为固定的目录名，以匹配缓存路径
          tar -xf "$sdk_filename"
          mv $(find . -maxdepth 1 -type d -name 'openwrt-sdk-*') ${{ env.SDK_DIR }}

          echo "Updating feeds..."
          cd ${{ env.SDK_DIR }}
          ./scripts/feeds update -a
          ./scripts/feeds install -a
          cd ..

      - name: Prepare build environment
        working-directory: ${{ env.SDK_DIR }}
        run: |
          rm -rf package/${PACKAGE_NAME}
          mkdir -p package/${PACKAGE_NAME}
          src_dir="${{ github.workspace }}"

          echo "Searching for Makefile in: $src_dir"
          # 查找 Makefile，最大深度3，按路径长度排序，优先取最短路径的(通常是根目录的)
          # 过滤掉路径中包含 /bin/ 或 /obj/ 的干扰项
          FOUND_MK=$(find "$src_dir" -maxdepth 3 -name Makefile -not -path "*/.*" | awk '{ print length, $0 }' | sort -n | cut -d" " -f2- | head -n 1)
          rsync -a --delete "$(dirname "$FOUND_MK")/" ./package/${PACKAGE_NAME}/

          if [ -z "$FOUND_MK" ]; then
            echo "::error::Could not find any Makefile in the repository!"
            ls -R "$src_dir"
            exit 1
          fi

          echo "Found primary Makefile at: $FOUND_MK"
          pkg_src_dir=$(dirname "$FOUND_MK")
          echo "Determined package source root: $pkg_src_dir"

          rsync -a --delete "${pkg_src_dir}/" ./package/${PACKAGE_NAME}/

          # 验证复制结果
          TARGET_MK="./package/${PACKAGE_NAME}/Makefile"
          if [ ! -f "$TARGET_MK" ]; then
            echo "::error::Failed to migrate code. Makefile missing at $TARGET_MK"
            ls -R package/${PACKAGE_NAME}
            exit 1
          fi
          echo "Code migration successful. Structure verified."

          # 检查 Makefile 中是否已存在 PKG_VERSION 定义
          if grep -q "^PKG_VERSION:=" "$TARGET_MK"; then
            echo "Static PKG_VERSION found in Makefile. Using upstream version definition."
            echo "::notice::You should not manually define PKG_VERSION or PKG_RELEASE in the Makefile. You should try using dynamic versioning."
          else
            echo "No static PKG_VERSION found. Applying dynamic versioning."

            NEW_VER=""
            NEW_REL=""

            if [ "${{ github.ref_type }}" = "tag" ]; then
              # === 场景 A: Release Tag ===
              NEW_VER=$(echo "${{ github.ref_name }}" | sed 's/^v//')
              NEW_REL="1"
              echo "Build triggered by Tag: Using Version=$NEW_VER, Release=$NEW_REL"
            else
              # === 场景 B: 普通 Commit (调试构建) ===
              # Version = 日期 (YYYY.MM.DD)
              NEW_VER=$(date +"%Y.%m.%d")

              # Release = BuildNumber.git-ShortHash
              SHORT_SHA=$(git -C "$src_dir" rev-parse --short HEAD)
              NEW_REL="${{ github.run_number }}.git-$SHORT_SHA"
              echo "Build triggered by Commit: Using Version=$NEW_VER, Release=$NEW_REL"
            fi

            # 动态注入版本号
            sed -i "s|include \$(TOPDIR)/rules.mk|include \$(TOPDIR)/rules.mk\nPKG_VERSION:=$NEW_VER\nPKG_RELEASE:=$NEW_REL|" "$TARGET_MK"
          fi

          mkdir -p ./bin/packages
          find ./bin/packages -type f -name "${PACKAGE_NAME}*.ipk" -delete
          find ./bin/packages -type f -name "${PACKAGE_NAME}*.apk" -delete

      - name: Compile the package
        working-directory: ${{ env.SDK_DIR }}
        run: |
          translation_pkg=${PACKAGE_NAME#luci-app-}

          # 为了实现 IPK 和 APK 的完全并行编译且互不干扰
          # 在父目录为 APK 编译创建一个 SDK 目录的硬链接副本
          cd ..
          SDK_DIR_NAME=$(basename ${{ env.SDK_DIR }})
          cp -al "$SDK_DIR_NAME" "${SDK_DIR_NAME}-apk"

          # --- 1. 编译 IPK (后台运行) ---
          (
            cd "$SDK_DIR_NAME"
            echo "Building IPK format..."
            {
              echo "CONFIG_PACKAGE_${PACKAGE_NAME}=m"
              echo "CONFIG_PACKAGE_luci-i18n-${translation_pkg}-zh-cn=m"
              echo "CONFIG_LUCI_LANG_zh_Hans=y"
            } > .config
            make defconfig
            make package/${PACKAGE_NAME}/compile V=sw -j$(nproc)
            mkdir -p output_ipk
            find ./bin/packages -type f \( -name "${PACKAGE_NAME}*.ipk" -o -name "luci-i18n-${translation_pkg}-*.ipk" \) -exec cp {} output_ipk/ \;
          ) &
          pid_ipk=$!

          # --- 2. 编译 APK (后台运行，在副本目录执行) ---
          (
            cd "${SDK_DIR_NAME}-apk"
            echo "Building APK format..."
            {
              echo "CONFIG_PACKAGE_${PACKAGE_NAME}=m"
              echo "CONFIG_PACKAGE_luci-i18n-${translation_pkg}-zh-cn=m"
              echo "CONFIG_LUCI_LANG_zh_Hans=y"
              echo "CONFIG_USE_APK=y"
            } > .config
            make defconfig
            if grep -q '^CONFIG_USE_APK=y' .config; then
              make package/${PACKAGE_NAME}/compile V=sw -j$(nproc)
              mkdir -p output_apk
              find ./bin/packages -type f \( -name "${PACKAGE_NAME}*.apk" -o -name "luci-i18n-${translation_pkg}-*.apk" \) -exec cp {} output_apk/ \;
            else
              echo "::warning::CONFIG_USE_APK not supported by this SDK. Skipping."
            fi
          ) &
          pid_apk=$!

          # 等待所有并行编译任务完成
          wait $pid_ipk $pid_apk

          # 将 APK 编译结果移动回主 SDK 目录以供后续步骤统一处理
          cd "$SDK_DIR_NAME"
          if [ -d "../${SDK_DIR_NAME}-apk/output_apk" ]; then
            mv "../${SDK_DIR_NAME}-apk/output_apk" ./
          fi

      - name: Collect artifacts
        id: collect_artifacts
        working-directory: ${{ env.SDK_DIR }}
        run: |
          REL_PATH="all"
          mkdir -p "upload/${REL_PATH}"
          [ -d "output_ipk" ] && cp output_ipk/*.ipk "upload/${REL_PATH}/" || true
          [ -d "output_apk" ] && cp output_apk/*.apk "upload/${REL_PATH}/" || true

          if [ -z "$(ls -A upload/${REL_PATH})" ]; then echo "No packages found!"; exit 1; fi

          # 签名处理
          if [ -z "${{ secrets.USIGN_KEY }}" ]; then
            echo "::warning title=Missing USIGN_KEY::GitHub Secret 'USIGN_KEY' is not set. A temporary key has been generated for this build."
            usign -G -s upload/key-build.sig -p upload/key-build.pub -c "Local build key"
            echo "::warning::Temporary signing key generated. Please save the following Private Key to your repository secrets as 'USIGN_KEY' to maintain consistent signatures:"
            echo "------------------- BEGIN KEY -------------------"
            cat upload/key-build.sig
            echo "-------------------- END KEY --------------------"
          else
            echo "${{ secrets.USIGN_KEY }}" > upload/key-build.sig
            usign -F -s upload/key-build.sig > upload/key-build.pub
          fi

          # 生成索引 (IPK)
          TARGET_DIR="upload/${REL_PATH}"
          if ls "${TARGET_DIR}"/*.ipk >/dev/null 2>&1; then
            touch "${TARGET_DIR}/Packages"
            for ipk in "${TARGET_DIR}"/*.ipk; do
              pkg_info=$(tar -xOzf "$ipk" ./control.tar.gz | tar -xOzf - ./control 2>/dev/null || tar -xOzf "$ipk" control.tar.gz | tar -xOzf - control)
              { echo "$pkg_info"; echo "Filename: $(basename $ipk)"; echo "Size: $(stat -c%s $ipk)"; echo "SHA256sum: $(sha256sum $ipk | awk '{print $1}')"; echo ""; } >> "${TARGET_DIR}/Packages"
            done
            gzip -9nc "${TARGET_DIR}/Packages" > "${TARGET_DIR}/Packages.gz"
            usign -S -m "${TARGET_DIR}/Packages" -s upload/key-build.sig -x "${TARGET_DIR}/Packages.sig"
          fi

          # 生成索引 (APK)
          if ls "${TARGET_DIR}"/*.apk >/dev/null 2>&1; then
            docker run --rm -v $(pwd)/${TARGET_DIR}:/work -w /work alpine sh -c "apk add apk-tools && apk index -o APKINDEX.tar.gz *.apk"
            usign -S -m "${TARGET_DIR}/APKINDEX.tar.gz" -s upload/key-build.sig -x "${TARGET_DIR}/APKINDEX.tar.gz.sig"
          fi

          echo "path=upload" >> $GITHUB_OUTPUT

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: packages-${{ matrix.target.name }}
          path: ${{ env.SDK_DIR }}/${{ steps.collect_artifacts.outputs.path }}

  deploy:
    name: Deploy to GitHub Pages
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages
        continue-on-error: true

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: downloaded-artifacts

      - name: Organize and Deploy
        run: |
          # 清除旧文件，确保只包含新生成的文件
          rm -rf deploy
          mkdir -p deploy/all

          # 只复制新生成的 ipk 和 apk 文件
          find downloaded-artifacts/packages-* -type f \( -name "*.ipk" -o -name "*.apk" -o -name "Packages*" -o -name "APKINDEX*" -o -name "key-build.pub" \) -exec cp {} deploy/all/ \;

          touch deploy/.nojekyll

          cat <<EOF > deploy/index.html
          <!DOCTYPE html>
          <html>
          <head>
              <meta charset="utf-8">
              <title>Tailscale Community LuCI App Repository</title>
              <style>
                  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; line-height: 1.6; max-width: 800px; margin: 40px auto; padding: 0 20px; color: #333; }
                  pre { background: #f6f8fa; padding: 16px; border-radius: 6px; overflow: auto; }
                  code { font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace; }
                  .footer { margin-top: 40px; font-size: 0.8em; color: #666; border-top: 1px solid #eee; padding-top: 20px; }
                  .arch-list { list-style: none; padding: 0; }
                  .arch-list li { margin-bottom: 10px; padding: 10px; background: #fff; border: 1px solid #e1e4e8; border-radius: 6px; }
              </style>
          </head>
          <body>
              <h1>Tailscale Community OPKG Feed</h1>
              <p>这是 <strong>luci-app-tailscale-community</strong> 的官方软件源托管地址。</p>

              <h3>如何使用 (How to use)</h3>
              <p>在你的 OpenWrt 终端运行以下命令：</p>
              <pre><code># 1. 添加公钥
          wget https://$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]').github.io/${{ env.PACKAGE_NAME }}/key-build.pub -O /tmp/key-build.pub
          opkg-key add /tmp/key-build.pub

          # 2. 添加软件源
          echo "src/gz tailscale_community https://$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]').github.io/${{ env.PACKAGE_NAME }}/all" >> /etc/opkg/customfeeds.conf

          # 3. 更新并安装
          opkg update
          opkg install luci-app-tailscale-community</code></pre>

              <h3>可用架构 (Available Architectures)</h3>
              <ul class="arch-list">
                  <li><strong>all</strong>: <code>https://$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]').github.io/${{ env.PACKAGE_NAME }}/all</code></li>
              </ul>

              <div class="footer">
                  <p>Generated by GitHub Actions at $(date -u)</p>
                  <p><a href="https://github.com/${{ github.repository }}">View on GitHub</a></p>
              </div>
          </body>
          </html>
          EOF

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./deploy
          force_orphan: true

  release:
    name: Publish Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          generate_release_notes: true
          files: |
            release-assets/packages-*/**/*.ipk
            release-assets/packages-*/**/*.apk
